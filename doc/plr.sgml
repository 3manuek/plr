<!doctype book PUBLIC "-//OASIS//DTD DocBook V3.1//EN">
<book>
 <title>PL/R User's Guide - R Procedural Language</title>
 <bookinfo>
  <copyright>
   <year>2003</year>
   <holder>Joseph E Conway</holder>
  </copyright>
 </bookinfo>

 <chapter id="plr-intro">
  <title>Introduction</title>

  <para>
   PL/R is a loadable procedural language that enables you to write
   PostgreSQL functions in the <ulink
   url="http://www.r-project.org/">R programming language</ulink>.
  </para>

  <note>
   <para>
    Note: Trigger procedures are not currently supported.
   </para>
  </note>

  <para>
   To install PL/R in a particular database, use
   <literal>createlang plr <replaceable>dbname</></literal>. Alternatively
   you can create the language manually using SQL commands:
   <programlisting>
CREATE FUNCTION plr_call_handler()
RETURNS LANGUAGE_HANDLER
AS '$libdir/plr' LANGUAGE C;

CREATE LANGUAGE plr HANDLER plr_call_handler;
   </programlisting>
  </para>

  <tip>
   <para>
    If a language is installed into <literal>template1</>, all subsequently
    created databases will have the language installed automatically.
   </para>
  </tip>

  <note>
   <para>
    If you build PostgreSQL from source, you must
    specially enable the build of PL/R during the installation process
    (refer to the installation instructions for more information).  Users of
    binary packages might find PL/R in a separate subpackage.
   </para>
  </note>

  <note>
   <para>
    R must have been built with the --enable-R-shlib option when it was
    configured, in order for the libR shared object library to be available.
   </para>
  </note>
 </chapter>

 <chapter id="plr-overview">
   <title>Overview</title>

   <para>
    PL/R offers most (if not all) of the capabilities a function
    writer has in the R language.
   </para>

   <para>
    A restriction is that only a few commands are available to access the
    database via SPI and to raise messages via <function>elog()</>. There
    is no way to access internals of the database backend. However the user
    is able to gain OS-level access under the permissions of the
    PostgreSQL user ID, as with a C function.
    Thus, any unprivileged database user should not be permitted to use this
    language. It <emphasis>must be installed as an untrusted procedural
    language</emphasis> so that only database superusers can create functions
    in it. The writer of a <application>PL/R</> function must take care that
    the function cannot be used to do anything unwanted, since it will be able
    to do anything that could be done by a user logged in as the database
    administrator.
   </para>

   <para>
    Another implementation restriction is that PL/R procedures cannot
    be used to create input/output functions for new data types.
   </para>

   <para>
    The shared object for the <application>R</> call handler is automatically
    built and installed in the PostgreSQL
    library directory if R support is specified during the configuration step
    of the installation procedure.  To install <application>PL/R</> in a
    particular database, use the <filename>createlang</filename> script, for
    example <literal>createlang plr <replaceable>dbname</></literal>.
   </para>
 </chapter>

 <chapter id="plr-funcs">
   <title>Functions and Arguments</title>

   <para>
    To create a function in the <application>PL/R</> language, use standard R
    syntax, but without the enclosing braces or function assignment.
    Instead of <literal>myfunc <- function(arguments) { function body }</literal>,
    the body of your PL/R function is just <literal>function body</literal>

    <programlisting>
CREATE OR REPLACE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-types</replaceable>)
RETURNS <replaceable>return-type</replaceable> AS '
    function body
' LANGUAGE 'plr';
    </programlisting>
   </para>

   <para>
    The body of the function is simply a piece of R script. When the function
    is called, the argument values are passed as variables <literal>
    arg1</literal> ... <literal>argN</literal> to the R script.  The result
    is returned from the R code in the usual way. For example, a function
    returning the greater of two integer values could be defined as:

    <programlisting>
CREATE OR REPLACE FUNCTION r_max (integer, integer) RETURNS integer AS '
    if (arg1 > arg2)
       return(arg1)
    else
       return(arg2)
' LANGUAGE 'plr' WITH (isStrict);
    </programlisting>

    Note the clause <literal>WITH (isStrict)</>, which saves us from
    having to think about NULL input values: if a NULL is passed, the
    function will not be called at all, but will just return a NULL
    result automatically.
   </para>

   <para>
    In a non-strict function, if the actual value of an argument
    is NULL, the corresponding <literal>argN</literal> variable will be set
    to an <literal>NA</literal> string. For example, suppose that we wanted
    <function>r_max</function> with one null and one non-null argument to
    return the non-null argument, rather than NULL:

    <programlisting>
CREATE OR REPLACE FUNCTION r_max (integer, integer) RETURNS integer AS '
    if (is.na(arg1) && is.na(arg2))
        return(NA)
    if (is.na(arg1))
        return(arg2)
    if (is.na(arg2))
        return(arg1)
    if (arg1 > arg2)
       return(arg1)
    arg2
' LANGUAGE 'plr';
    </programlisting>
   </para>

   <para>
    As shown above, to return a NULL value from a PL/R function, return
    <literal>NA</literal>.  This can be done whether the function is strict
    or not.
   </para>

   <para>
    Composite-type (tuple) arguments are passed to the procedure as
    R data.frames. The element names of the frame are the attribute
    names of the composite type. If an attribute in the passed row
    has the NULL value, it will appear as an "NA" in the frame. Here is
    an example:

    <programlisting>
CREATE TABLE emp (name text, age int, salary numeric(10,2));
INSERT INTO emp VALUES ('Joe', 41, 250000.00);
INSERT INTO emp VALUES ('Jim', 25, 120000.00);
INSERT INTO emp VALUES ('Jon', 35, 50000.00);
CREATE OR REPLACE FUNCTION overpaid (emp) RETURNS bool AS '
    if (200000 < arg1$salary) {
        return(TRUE)
    }
    if (arg1$age < 30 && 100000 < arg1$salary) {
        return(TRUE)
    }
    return(FALSE)
' LANGUAGE 'plr';
regression=# SELECT name, overpaid(emp) FROM emp;
 name | overpaid
------+----------
 Joe  | t
 Jim  | t
 Jon  | f
(3 rows)

    </programlisting>
   </para>

   <para>
    There is also support for returning a composite-type result value:

    <programlisting>
CREATE OR REPLACE FUNCTION get_emps() RETURNS SETOF emp AS '
    names <- c("Joe","Jim","Jon")
    ages <- c(41,25,35)
    salaries <- c(250000,120000,50000)
    df <- data.frame(name = names, age = ages, salary = salaries)
    return(df)
' LANGUAGE 'plr';
regression=# select * from get_emps();
 name | age |  salary
------+-----+-----------
 Jim  |  41 | 250000.00
 Joe  |  25 | 120000.00
 Jon  |  35 |  50000.00
(3 rows)

    </programlisting>
   </para>

   <tip>
    <para>
     Because the function body is passed as an SQL string literal to
     <command>CREATE FUNCTION</command>, you have to escape single
     quotes and backslashes within your R source, typically by
     doubling them.
    </para>
   </tip>
 </chapter>

 <chapter id="plr-data">
   <title>Passing Data Values</title>

   <para>
    The argument values supplied to a PL/R function's script are simply
    the input arguments converted to a corresponding R form.
    See <xref linkend="plr-args-table">. Scalar PostgreSQL
    values become single element R vectors. One-dimensional
    PostgreSQL arrays are converted to multi-element
    R vectors, and two-dimensional PostgreSQL arrays
    are mapped to R matrixes, but greater than two-dimensional arrays are not
    supported. Composite-types are transformed into R data.frames.
   </para>

   <table id="plr-args-table">
    <title>Function Arguments</title>
    <tgroup cols="2">
     <thead>
      <row>
        <entry>PostgreSQL type</entry>
        <entry>R type</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry><type>boolean</type></entry>
       <entry><type>logical</type></entry>
      </row>

      <row>
       <entry><type>int2</type>, <type>int4</type></entry>
       <entry><type>integer</type></entry>
      </row>

      <row>
       <entry><type>int8</type>, <type>float4</type>, <type>float8</type>,
              <type>cash</type>, <type>numeric</type></entry>
       <entry><type>numeric</type></entry>
      </row>

      <row>
       <entry>everything else</entry>
       <entry><type>character</type></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
    Conversely, the return values are first coerced to R character, and
    therefore anything that resolves to a string that is acceptable input
    format for the function's declared return type will produce a result.
    Similar to argument conversion, there is also a mapping between the
    dimensionality of the declared PostgreSQL return type and the type of
    R object. That mapping is shown in 
    <xref linkend="plr-data-results-dims-table">
   </para>

   <table id="plr-data-results-dims-table">
    <title>Function Result Dimensionality</title>
    <tgroup cols="4">
     <thead>
      <row>
       <entry>PgSQL return type</entry>
       <entry>R type</entry>
       <entry>Result</entry>
       <entry>Example</entry>
      </row>
     </thead>

     <tbody>

      <row>
       <entry><type>scalar</type></entry>
       <entry><type>array</type>, <type>matrix</type>, <type>vector</type></entry>
       <entry>first column of first row</entry>
       <entry>c(1,2,3) in R returns 1 in PostgreSQL</entry>
      </row>

      <row>
       <entry><type>scalar</type></entry>
       <entry><type>data.frame</type></entry>
       <entry>textual representation of the first column's vector</entry>
       <entry>data.frame(c(1,2,3)) in R returns 'c(1, 2, 3)'</entry>
      </row>

      <row>
       <entry><type>array</type></entry>
       <entry><type>1D array</type>, <type>greater than 2D array</type>, <type>vector</type></entry>
       <entry>1D array</entry>
       <entry>array(1:8,c(2,2,2)) in R returns {1,2,3,4,5,6,7,8}</entry>
      </row>

      <row>
       <entry><type>array</type></entry>
       <entry><type>2D array</type>, <type>matrix</type>, <type>data.frame</type></entry>
       <entry>2D array</entry>
       <entry>array(1:4,c(2,2)) in R returns {{1,3},{2,4}}</entry>
      </row>

      <row>
       <entry><type>composite</type></entry>
       <entry><type>1D array</type>, <type>greater than 2D array</type>, <type>vector</type></entry>
       <entry>1 column set</entry>
       <entry>array(1:8,c(2,2,2)) in R returns 8 rows of scalar</entry>
      </row>

      <row>
       <entry><type>composite</type></entry>
       <entry><type>2D array</type>, <type>matrix</type>, <type>data.frame</type></entry>
       <entry>multi-column set</entry>
       <entry>array(1:4,c(2,2)) in R returns 2 rows of 2 columns</entry>
      </row>

     </tbody>
    </tgroup>
   </table>
 </chapter>

 <chapter id="plr-global-data">
   <title>Using Global Data</title>

   <para>
    Sometimes it is useful to have some global status data that is held
    between two calls to a procedure or is shared between different
    procedures. Equally useful is the ability to create functions that
    your PL/R functions can share. This is easily done since all PL/R
    procedures executed in one backend share the same R interpreter.  So,
    any global R variable is accessible to all PL/R procedure calls, and
    will persist for the duration of the SQL client connection.
   </para>

   <para>
    An example of using a global object appears in the
    <function>pg.spi.execp</function> example. A globally available
    R function can be created dynamically using the provided PostgreSQL
    function <function>install_rcmd(text)</function>. Here is an example:
    <programlisting>
select install_rcmd('pg.test.install <-function(msg) {print(msg)}');
 install_rcmd 
--------------
 OK
(1 row)

create or replace function pg_test_install(text) returns text as 'pg.test.install(arg1)' language 'plr';
select pg_test_install('hello world');
 pg_test_install 
-----------------
 hello world
(1 row)
    </programlisting>
   </para>
 </chapter>

 <chapter id="plr-rsupport-funcs">
   <title>Database Access</title>

    <para>
     The following commands are available to access the database from
     the body of a PL/R procedure:
    </para>

    <variablelist>

     <varlistentry>
      <term><function>pg.spi.exec</function>(<replaceable>query</replaceable>)</term>
      <listitem>
       <para>
        Execute an SQL query given as a string.  An error in the query
        causes an error to be raised.  Otherwise, the command's return value
        is the number of rows processed for <command>INSERT</command>, 
        <command>UPDATE</command>, or <command>DELETE</command> statements,
        or zero if the query is a utility statement.  If the query is a
        <command>SELECT</command> statement, the values of the selected columns
        are placed in an R data.frame with the target column names used as
        the frame column names. However, non-numeric columns <emphasis>are
        not</emphasis> converted to factors. If you want all non-numeric
        columns converted to factors, a convenience function <function>
        pg.spi.factor</function> (described below) is provided.
       </para>

       <para>
        If a field of a SELECT result is NULL, the target variable for it
        is set to <quote>NA</quote>. For example:
        <programlisting>
create or replace function test_spi_tup(text) returns record as 'pg.spi.exec(arg1)' language 'plr';
regression=# select * from test_spi_tup('select oid, NULL::text as nullcol, typname from pg_type where typname = ''oid'' or typname = ''text''') as t(typeid oid, nullcol text, typename name);
 typeid | nullcol | typename
--------+---------+----------
     25 |         | text
     26 |         | oid
(2 rows)
        </programlisting>
        The NULL values were passed to R as <quote>NA</quote>, and on return to
        PostgreSQL they were converted back to NULL.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>pg.spi.prepare</function>(
                      <replaceable>query</replaceable>, 
                      <replaceable>type_vector</replaceable>)</term>
      <listitem>
       <para>
        Prepares and saves a query plan for later execution. The saved plan
        will be retained for the life of the current backend.
       </para>

       <para>
        The query may use <firstterm>arguments</>, which are placeholders for
        values to be supplied whenever the plan is actually executed. In the
        query string, refer to arguments by the symbols <literal>$1</literal>
        ... <literal>$n</literal>. If the query uses arguments, the values of
        the argument types must be given as vector. Pass an empty vector for
        <replaceable>type vector</replaceable> if no arguments are used.
        The argument types must be identified by the type Oids, shown
        in pg_type. Global variables are provided for this use. They are
        named according to the convention TYPENAMEOID, where the actual name of
        the type, in all capitals, is substituted for TYPENAME. A support
        function, <function>r_typenames()</function> can be used to list the
        predefined Global variables:
        <programlisting>
regression=# select * from r_typenames();
    typename     | typeoid
-----------------+---------
 ABSTIMEOID      |     702
 ACLITEMOID      |    1033
 ANYARRAYOID     |    2277
 ANYOID          |    2276
 BITOID          |    1560
 BOOLOID         |      16
  [...]
 TRIGGEROID      |    2279
 UNKNOWNOID      |     705
 VARBITOID       |    1562
 VARCHAROID      |    1043
 VOIDOID         |    2278
 XIDOID          |      28
(59 rows)
        </programlisting>
       </para>

       <para>
        The return value from <function>pg.spi.prepare</function> is a query ID
        to be used in subsequent calls to <function>pg.spi.execp</function>. See
        <function>spi_execp</function> for an example.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>pg.spi.execp</> <literal>?-count <replaceable>n</replaceable>? ?-array <replaceable>name</replaceable>? ?-nulls <replaceable>string</replaceable>? <replaceable>queryid</replaceable> ?<replaceable>value-list</replaceable>? ?<replaceable>loop-body</replaceable>?</literal></term>
      <listitem>
       <para>
	Execute a query previously prepared with <function>spi_prepare</>.
	<replaceable>queryid</replaceable> is the ID returned by
	<function>spi_prepare</>.  If the query references arguments,
	a <replaceable>value-list</replaceable> must be supplied: this
	is a Tcl list of actual values for the arguments.  This must be
	the same length as the argument type list previously given to
	<function>spi_prepare</>.  Omit <replaceable>value-list</replaceable>
	if the query has no arguments.
       </para>
       <para>
	The optional value for <literal>-nulls</> is a string of spaces and
	<literal>'n'</> characters telling <function>spi_execp</function>
	which of the arguments are null values. If given, it must have exactly the
	same length as the <replaceable>value-list</replaceable>.  If it
	is not given, all the argument values are non-NULL.
       </para>
       <para>
        Except for the way in which the query and its arguments are specified,
	<function>spi_execp</> works just like <function>spi_exec</>.
        The <literal>-count</>, <literal>-array</>, and
	<replaceable>loop-body</replaceable> options are the same,
	and so is the result value.
       </para>
       <para>
	Here's an example of a PL/Tcl function using a prepared plan:

	<programlisting>
CREATE FUNCTION t1_count(integer, integer) RETURNS integer AS '
    if {![ info exists GD(plan) ]} {
        # prepare the saved plan on the first call
        set GD(plan) [ spi_prepare \\
                "SELECT count(*) AS cnt FROM t1 WHERE num >= \\$1 AND num <= \\$2" \\
                [ list int4 int4 ] ]
    }
    spi_execp -count 1 $GD(plan) [ list $1 $2 ]
    return $cnt
' LANGUAGE 'pltcl';
	</programlisting>

	Note that each backslash that Tcl should see must be doubled when
	we type in the function, since the main parser processes
	backslashes too in CREATE FUNCTION.  We need backslashes inside
	the query string given to <function>spi_prepare</> to ensure that
	the <literal>$n</> markers will be passed through to
	<function>spi_prepare</> as-is, and not
	replaced by Tcl variable substitution.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <indexterm>
       <primary>spi_lastoid</primary>
      </indexterm>
      <term><function>spi_lastoid</></term>
      <listitem>
       <para>
	Returns the OID of the row inserted by the last
	<function>spi_exec</>'d or <function>spi_execp</>'d query,
	if that query was a single-row INSERT.  (If not, you get zero.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>quote</> <replaceable>string</replaceable></term>
      <listitem>
       <para>
	Duplicates all occurrences of single quote and backslash characters
	in the given string.  This may be used to safely quote strings
	that are to be inserted into SQL queries given
	to <function>spi_exec</function> or
	<function>spi_prepare</function>.
	For example, think about a query string like

<programlisting>
"SELECT '$val' AS ret"
</programlisting>

	where the Tcl variable val actually contains
	<literal>doesn't</literal>. This would result
	in the final query string

<programlisting>
SELECT 'doesn't' AS ret
</programlisting>

	which would cause a parse error during
	<function>spi_exec</function> or
	<function>spi_prepare</function>.
	The submitted query should contain

<programlisting>
SELECT 'doesn''t' AS ret
</programlisting>

	which can be formed in PL/Tcl as

<programlisting>
"SELECT '[ quote $val ]' AS ret"
</programlisting>

        One advantage of <function>spi_execp</function> is that you don't
	have to quote argument values like this, since the arguments are never
	parsed as part of an SQL query string.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <indexterm>
       <primary>elog</primary>
      </indexterm>
      <term><function>elog</> <replaceable>level</replaceable> <replaceable>msg</replaceable></term>
      <listitem>
       <para>
	Emit a log or error message. Possible levels are
	<literal>DEBUG</>, <literal>LOG</>, <literal>INFO</>,
	<literal>NOTICE</>, <literal>WARNING</>, <literal>ERROR</>, and
	<literal>FATAL</>. Most simply emit the given message just like
	the <literal>elog</> backend C function. <literal>ERROR</>
	raises an error condition: further execution of the function is
	abandoned, and the current transaction is aborted.
	<literal>FATAL</> aborts the transaction and causes the current
	backend to shut down (there is probably no good reason to use
	this error level in PL/Tcl functions, but it's provided for
	completeness).
       </para>
      </listitem>
     </varlistentry>

    </variablelist>




 </chapter>




 <chapter id="plr-oldtclstuff">
  <title>Old Tcl stuff</title>

   <sect1>
    <title>Trigger Procedures in PL/Tcl</title>

    <indexterm>
     <primary>triggers</primary>
     <secondary>in PL/Tcl</secondary>
    </indexterm>

    <para>
     Trigger procedures can be written in PL/Tcl.  As is customary in
     PostgreSQL, a procedure that's to be called
     as a trigger must be declared as a function with no arguments
     and a return type of <literal>trigger</>.
    </para>
    <para>
     The information from the trigger manager is passed to the procedure body
     in the following variables:

     <variablelist>

      <varlistentry>
       <term><replaceable class="Parameter">$TG_name</replaceable></term>
       <listitem>
	<para>
	 The name of the trigger from the CREATE TRIGGER statement.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable class="Parameter">$TG_relid</replaceable></term>
       <listitem>
	<para>
	 The object ID of the table that caused the trigger procedure
	 to be invoked.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable class="Parameter">$TG_relatts</replaceable></term>
       <listitem>
	<para>
	 A Tcl list of the table field names, prefixed with an empty list
         element. So looking up an element name in the list with <application>Tcl</>'s
         <function>lsearch</> command returns the element's number starting
	 with 1 for the first column, the same way the fields are customarily
	 numbered in PostgreSQL.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable class="Parameter">$TG_when</replaceable></term>
       <listitem>
	<para>
	 The string <literal>BEFORE</> or <literal>AFTER</> depending on the
	 type of trigger call.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable class="Parameter">$TG_level</replaceable></term>
       <listitem>
	<para>
	 The string <literal>ROW</> or <literal>STATEMENT</> depending on the
	 type of trigger call.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable class="Parameter">$TG_op</replaceable></term>
       <listitem>
	<para>
	 The string <literal>INSERT</>, <literal>UPDATE</> or
	 <literal>DELETE</> depending on the type of trigger call.
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable class="Parameter">$NEW</replaceable></term>
       <listitem>
	<para>
	 An associative array containing the values of the new table row for
	 INSERT/UPDATE actions, or empty for DELETE.  The array is indexed
	 by field name.  Fields that are NULL will not appear in the array!
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable class="Parameter">$OLD</replaceable></term>
       <listitem>
	<para>
	 An associative array containing the values of the old table row for
	 UPDATE/DELETE actions, or empty for INSERT.  The array is indexed
	 by field name.  Fields that are NULL will not appear in the array!
	</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term><replaceable class="Parameter">$args</replaceable></term>
       <listitem>
	<para>
	 A Tcl list of the arguments to the procedure as given in the
	 CREATE TRIGGER statement. These arguments are also accessible as
	 <literal>$1</literal> ... <literal>$n</literal> in the procedure body.
	</para>
       </listitem>
      </varlistentry>

     </variablelist>
    </para>

    <para>
     The return value from a trigger procedure can be one of the strings
     <literal>OK</> or <literal>SKIP</>, or a list as returned by the
     <literal>array get</> Tcl command. If the return value is <literal>OK</>,
     the operation (INSERT/UPDATE/DELETE) that fired the trigger will proceed
     normally. <literal>SKIP</> tells the trigger manager to silently suppress
     the operation for this row. If a list is returned, it tells PL/Tcl to
     return a modified row to the trigger manager that will be inserted
     instead of the one given in $NEW (this works for INSERT/UPDATE
     only). Needless to say that all this is only meaningful when the trigger
     is BEFORE and FOR EACH ROW; otherwise the return value is ignored.
    </para>
    <para>
     Here's a little example trigger procedure that forces an integer value
     in a table to keep track of the number of updates that are performed on the
     row. For new rows inserted, the value is initialized to 0 and then
     incremented on every update operation:

     <programlisting>
CREATE FUNCTION trigfunc_modcount() RETURNS TRIGGER AS '
    switch $TG_op {
        INSERT {
            set NEW($1) 0
        }
        UPDATE {
            set NEW($1) $OLD($1)
            incr NEW($1)
        }
        default {
            return OK
        }
    }
    return [array get NEW]
' LANGUAGE 'pltcl';

CREATE TABLE mytab (num integer, description text, modcnt integer);

CREATE TRIGGER trig_mytab_modcount BEFORE INSERT OR UPDATE ON mytab
    FOR EACH ROW EXECUTE PROCEDURE trigfunc_modcount('modcnt');
     </programlisting>

     Notice that the trigger procedure itself does not know the column
     name; that's supplied from the trigger arguments.  This lets the
     trigger procedure be re-used with different tables.
    </para>
   </sect1>

   <sect1>
       <title> Modules and the <function>unknown</> command</title>
       <para>
	PL/Tcl has support for auto-loading Tcl code when used.
	It recognizes a special table, <literal>pltcl_modules</>, which
	is presumed to contain modules of Tcl code.  If this table
	exists, the module <literal>unknown</> is fetched from the table
	and loaded into the Tcl interpreter immediately after creating
	the interpreter.
       </para>
       <para>
        While the <literal>unknown</> module could actually contain any
	initialization script you need, it normally defines a Tcl
	<quote>unknown</> procedure that is invoked whenever Tcl does
	not recognize an invoked procedure name.  <application>PL/Tcl</>'s standard version
	of this procedure tries to find a module in <literal>pltcl_modules</>
	that will define the required procedure.  If one is found, it is
	loaded into the interpreter, and then execution is allowed to
	proceed with the originally attempted procedure call.  A
	secondary table <literal>pltcl_modfuncs</> provides an index of
	which functions are defined by which modules, so that the lookup
	is reasonably quick.
       </para>
       <para>
        The PostgreSQL distribution includes
	support scripts to maintain these tables:
	<command>pltcl_loadmod</>, <command>pltcl_listmod</>,
	<command>pltcl_delmod</>, as well as source for the standard
	unknown module <filename>share/unknown.pltcl</>.  This module
	must be loaded
	into each database initially to support the autoloading mechanism.
       </para>
       <para>
        The tables <literal>pltcl_modules</> and <literal>pltcl_modfuncs</>
	must be readable by all, but it is wise to make them owned and
	writable only by the database administrator.
       </para>
   </sect1>

   <sect1>
    <title>Tcl Procedure Names</title>

    <para>
     In PostgreSQL, one and the 
     same function name can be used for
     different functions as long as the number of arguments or their types
     differ. Tcl, however, requires all procedure names to be distinct.
     PL/Tcl deals with this by making the internal Tcl procedure names contain
     the object 
     ID of the procedure's <structname>pg_proc</> row as part of their name. Thus,
     PostgreSQL functions with the same name
     and different argument types will be different Tcl procedures too.  This
     is not normally a concern for a PL/Tcl programmer, but it might be visible
     when debugging.
    </para>

   </sect1>
 </chapter>
</book>
<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../../../doc/src/sgml/reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
